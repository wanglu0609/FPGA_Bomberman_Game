//-------------------------------------------------------------------------
//    Color_Mapper.sv                                                    --
//    Stephen Kempf                                                      --
//    3-1-06                                                             --
//                                                                       --
//    Modified by David Kesler  07-16-2008                               --
//    Translated by Joe Meng    07-07-2013                               --
//    Modified by Po-Han Huang  03-03-2017                               --
//                                                                       --
//    Spring 2017 Distribution                                           --
//                                                                       --
//    For use with ECE 385 Lab 7                                         --
//    University of Illinois ECE Department                              --
//-------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
// ( 24, 24)|( 72, 24)|(120, 24)|(168, 24)|(216, 24)|(264, 24)|(312, 24)|(360, 24)|(408, 24)|(456, 24)
// ( 24, 72)|( 72, 72)|(120, 72)|(168, 72)|(216, 72)|(264, 72)|(312, 72)|(360, 72)|(408, 72)|(456, 72)
// ( 24,120)|( 72,120)|(120,120)|(168,120)|(216,120)|(264,120)|(312,120)|(360,120)|(408,120)|(456,120)
// ( 24,168)|( 72,168)|(120,168)|(168,168)|(216,168)|(264,168)|(312,168)|(360,168)|(408,168)|(456,168)
// ( 24,216)|( 72,216)|(120,216)|(168,216)|(216,216)|(264,216)|(312,216)|(360,216)|(408,216)|(456,216)
// ( 24,264)|( 72,264)|(120,264)|(168,264)|(216,264)|(264,264)|(312,264)|(360,264)|(408,264)|(456,264)
// ( 24,312)|( 72,312)|(120,312)|(168,312)|(216,312)|(264,312)|(312,312)|(360,312)|(408,312)|(456,312)
// ( 24,360)|( 72,360)|(120,360)|(168,360)|(216,360)|(264,360)|(312,360)|(360,360)|(408,360)|(456,360)
// ( 24,408)|( 72,408)|(120,408)|(168,408)|(216,408)|(264,408)|(312,408)|(360,408)|(408,408)|(456,408)
// ( 24,456)|( 72,456)|(120,456)|(168,456)|(216,456)|(264,456)|(312,456)|(360,456)|(408,456)|(456,456)
//--------------------------------------------------------------------------------------------------



module  Color_Mapper_Final (
	input [9:0] Avatar_X_1, Avatar_Y_1, Avatar_Step_1,     // Ball coordinates
	            Avatar_X_2, Avatar_Y_2, Avatar_Step_2,
					Draw_X, Draw_Y,      // Coordinates of current drawing pixel
	input [1:0] Avatar_Dir_1,  Avatar_Dir_2, 
   input [143:0] Wall_Map, Tree_Map, Treasure_Map, Bomb_Map, Flame_Map,
	output logic [7:0] VGA_R, VGA_G, VGA_B // VGA RGB output
);
 
	logic [7:0] c_table[0:7][0:2];
	logic [7:0] Red, Green, Blue;
	logic [7:0] av_index_1, av_index_2,
	            tile_index, small_index, big_index;
	logic [7:0] avf [0:179][0:39];
   logic [7:0] avr [0:179][0:39];
	logic [7:0] avb [0:179][0:39];
	logic [7:0] ground [0:39][0:39];
	logic [7:0] tree [0:39][0:39];
	logic [7:0] bomb_1 [0:27][0:27];
	logic [7:0] flame_1 [0:27][0:27];
	logic [7:0] wall [0:39][0:39];
	logic front_on_2, right_on_2, left_on_2, back_on_2, wall_on, tree_on, flame_on, bomb_on,
	      front_on_1, right_on_1, left_on_1, back_on_1, av_1, av_2;

	color_table color(.colors(c_table));
	front ava_f(.index(avf));
	right ava_r(.index(avr));
	back ava_b(.index(avb));
	tile background(.index(ground));
	Solid solidwall(.index(wall));
	flame fire(.index(flame_1));
	bomb explode(.index(bomb_1));
	exploded EB(.index(tree));

	/* The ball's (pixelated) circle is generated using the standard circle formula.  Note that while 
	the single line is quite powerful descriptively, it causes the synthesis tool to use up three
	of the 12 available multipliers on the chip! Since the multiplicants are required to be signed,
	we have to first cast them from logic to int (signed by default) before they are multiplied. */

	int Char_X_1, Char_Y_1, loc_x_1, loc_y_1, Char_X_2, Char_Y_2, loc_x_2, loc_y_2, move_1, move_2;
	int step_1, step_2, t1, t2, width, height, cell_x, cell_y;
	assign Char_X_1 = Avatar_X_1;
	assign Char_Y_1 = Avatar_Y_1;
   assign Char_X_2 = Avatar_X_2;
	assign Char_Y_2 = Avatar_Y_2;
	assign width = 40;
	assign height = 60;
	assign loc_x_1 = Draw_X - Char_X_1 + width;
	assign loc_y_1 = Draw_Y - Char_Y_1 + height;
   assign loc_x_2 = Draw_X - Char_X_2 + width;
	assign loc_y_2 = Draw_Y - Char_Y_2 + height;
	assign step_1 = Avatar_Step_1;
	assign step_2 = Avatar_Step_2;
	assign move_1 = (step_1/4) % 2;
	assign move_2 = (step_2/4) % 2;
	assign t1 = Draw_X % 40;
   assign t2 = Draw_Y % 40;
	assign cell_x = Draw_X / 40;
	assign cell_y = Draw_Y / 40;
	
	assign tile_index = ground[t2][t1];
	
	assign VGA_R = Red;
	assign VGA_G = Green;
	assign VGA_B = Blue;

	

	// Compute whether the pixel corresponds to ball or background
	always_comb
	begin : find_index
		if(Draw_X >= Char_X_1 - width && Draw_X < Char_X_1 + width && Draw_Y >= Char_Y_1 - height && Draw_Y < Char_Y_1 + height) 
		begin
			if(Avatar_Dir_1==2'b00)
			begin 
			   front_on_1 = 1'b1;
			   av_1 = 1'b1;
			end
			else if(Avatar_Dir_1==2'b01)
			begin 
			   back_on_1 = 1'b1;
			   av_1 = 1'b1;
			end
			else if(Avatar_Dir_1==2'b10)
			begin 
			   left_on_1 = 1'b1;
			   av_1 = 1'b1;
			end
			else
			begin 
			   right_on_1 = 1'b1;
			   av_1 = 1'b1;
			end

		end
		else
		   av_1 = 1'b0;
		if(Draw_X >= Char_X_2 - width && Draw_X < Char_X_2 + width && Draw_Y >= Char_Y_2 - height && Draw_Y < Char_Y_2 + height) 
		begin
		   if(Avatar_Dir_2==2'b00)
			begin 
			   front_on_2 = 1'b1;
			   av_2 = 1'b1;
			end
			else if(Avatar_Dir_2==2'b01)
			begin 
			   back_on_2 = 1'b1;
			   av_2 = 1'b1;
			end
			else if(Avatar_Dir_2==2'b10)
			begin 
			   left_on_2 = 1'b1;
			   av_2 = 1'b1;
			end
			else
			begin 
			   right_on_2 = 1'b1;
			   av_2 = 1'b1;
			end

		end
		else
		   av_2 = 1'b0;
		
		if(Bomb_Map[cell_y*40+cell_x])
		   bomb_on = 1'b1;
		else if(Flame_Map[cell_y*40+cell_x])
		   flame_on = 1'b1;
		else if(Wall_Map[cell_y*40+cell_x])
		   wall_on = 1'b1;
		else if(Tree_Map[cell_y*40+cell_x])
		   tree_on = 1'b1;
		else 
		begin
			bomb_on = 1'b0;
			wall_on = 1'b0;
			tree_on = 1'b0;
			flame_on = 1'b0;
		end
	end

	
	
	
	

	always_comb
   begin : color_picker
	   if (front_on_1 == 1'b1) 
		begin
		   if((step_1<2)&&(step_1>37))
		   begin
			    av_index_1 = avf[loc_y_1+60][loc_x_1];
		   end
	   	else if (move_1 == 0)
		   begin
             av_index_1 = avf[loc_y_1+120][loc_x_1];
			end
	   	else
		   begin
             av_index_1 = avf[loc_y_1][loc_x_1];
			end
			
		end
		else if (back_on_1 == 1'b1) 
		begin
		   if((step_1<2)&&(step_1>37))
		   begin
			    av_index_1 = avb[loc_y_1+60][loc_x_1];
		   end
	   	else if (move_1 == 0)
		   begin
             av_index_1 = avb[loc_y_1+120][loc_x_1];
			end
	   	else
		   begin
             av_index_1 = avb[loc_y_1][loc_x_1];
			end
			
		end
		else if (right_on_1 == 1'b1) 
		begin
		   if((step_1<2)&&(step_1>37))
		   begin
			    av_index_1 = avr[loc_y_1+60][loc_x_1];
		   end
	   	else if (move_1 == 0)
		   begin
             av_index_1 = avr[loc_y_1+120][loc_x_1];
			end
	   	else
		   begin
             av_index_1 = avr[loc_y_1][loc_x_1];
			end
			
		end
			   if (left_on_1 == 1'b1) 
		begin
		   if((step_1<2)&&(step_1>37))
		   begin
			    av_index_1 = avr[loc_y_1+60][39-loc_x_1];
		   end
	   	else if (move_1 == 0)
		   begin
             av_index_1 = avr[loc_y_1+120][39-loc_x_1];
			end
	   	else
		   begin
             av_index_1 = avr[loc_y_1][39-loc_x_1];
			end
			
		end
		else
		begin
		   av_1 = 1'b0;
		end
		//second player
	   if (front_on_2 == 1'b1) 
		begin
		   if((step_2<2)&&(step_2>37))
		   begin
			    av_index_2 = avf[loc_y_2+60][loc_x_2];
		   end
	   	else if (move_2 == 0)
		   begin
             av_index_2 = avf[loc_y_2+120][loc_x_2];
			end
	   	else
		   begin
             av_index_2 = avf[loc_y_2][loc_x_2];
			end
			
		end
		else if (back_on_2 == 1'b1) 
		begin
		   if((step_2<2)&&(step_2>37))
		   begin
			    av_index_2 = avb[loc_y_2+60][loc_x_2];
		   end
	   	else if (move_2 == 0)
		   begin
             av_index_2 = avb[loc_y_2+120][loc_x_2];
			end
	   	else
		   begin
             av_index_2 = avb[loc_y_2][loc_x_2];
			end
			
		end
		else if (right_on_2 == 1'b1) 
		begin
		   if((step_2<2)&&(step_2>37))
		   begin
			    av_index_2 = avr[loc_y_2+60][loc_x_2];
		   end
	   	else if (move_2 == 0)
		   begin
             av_index_2 = avr[loc_y_2+120][loc_x_2];
			end
	   	else
		   begin
             av_index_2 = avr[loc_y_2][loc_x_2];
			end
			
		end
		else if (left_on_2 == 1'b1) 
		begin
		   if((step_2<2)&&(step_2>37))
		   begin
			    av_index_2 = avr[loc_y_2+60][39-loc_x_2];
		   end
	   	else if (move_2 == 0)
		   begin
             av_index_2 = avr[loc_y_2+120][39-loc_x_2];
			end
	   	else
		   begin
             av_index_2 = avr[loc_y_2][39-loc_x_2];
			end
			
		end
		else
		begin
		   av_2 = 1'b0;
		end		
			
		if(bomb_on == 1'b1)
		begin
			small_index =  bomb_1[t2-6][t1-6];
		end
		else if(tree_on == 1'b1)
		begin
			big_index =  tree[t2][t1];
		end
		else if(wall_on == 1'b1)
		begin
		   big_index = wall[t2][t1];
		end
		else if(flame_on == 1'b1)
		begin
		   small_index = flame_1[t2-6][t1-6];
		end
		else
		begin
			big_index = 0;
			small_index = 0;
		end
	end 

	
	
	

	
	// Assign color based on ball_on signal
	always_comb
	begin : RGB_Display
		if ((av_1 == 1'b1) && (av_index_1 != 0)) 
		begin
			Red = c_table[av_index_1][0];
			Green = c_table[av_index_1][1];
			Blue = c_table[av_index_1][2];
		end
		else if((av_2 == 1'b1) && (av_index_2 != 0)) 
		begin
			Red = c_table[av_index_2][0];
			Green = c_table[av_index_2][1];
			Blue = c_table[av_index_2][2];
		end
		else if ((bomb_on == 1'b1) && (small_index != 0)) 
		begin
			// White ball
			Red = c_table[small_index][0];
			Green = c_table[small_index][1];
			Blue = c_table[small_index][2];
		end
		else if ((wall_on == 1'b1) && (big_index != 0)) 
		begin
			// White ball
			Red = c_table[big_index][0];
			Green = c_table[big_index][1];
			Blue = c_table[big_index][2];
		end
		else if ((tree_on == 1'b1) && (big_index != 0)) 
		begin
			// White ball
			Red = c_table[big_index][0];
			Green = c_table[big_index][1];
			Blue = c_table[big_index][2];
		end
		else if ((flame_on == 1'b1) && (small_index != 0)) 
		begin
			// White ball
			Red = c_table[small_index][0];
			Green = c_table[small_index][1];
			Blue = c_table[small_index][2];
		end
		else if(Draw_X < 480)
		begin
			// Background with nice color gradient
			Red = c_table[tile_index][0];
			Green = c_table[tile_index][1];
			Blue = c_table[tile_index][2];
		end
		else
		begin
			// Background with nice color gradient
			Red = 8'd52;
			Green = 8'd61;
			Blue = 8'd70;
		end
	end 

endmodule
